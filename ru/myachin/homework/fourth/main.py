# ### Задача 1
# Написать функцию `sumprod(u, v)`, принимающую на вход два списка и вычисляющая сумму попарных произведений их
# элементов. Например, `sumprod([1, 2, 3], [4, 5, 6])` должен вернуть результат
# вычисления `1 * 4 + 2 * 5 + 3 * 6`, то есть 32.
# 
# **Подсказка.** Здесь нужно использовать `zip`.

def sumprod(u, v):
    list = [x * y for x, y in zip(u, v)]
    return sum(list)


# ### Задача 2
# Написать функцию `elementwise_concat(words1, words2, sep)`, принимающую на вход два списка строк `words1` и `words2`
# и строку `sep`, и возвращающую список, состовленный следующим образом: его первый элемент — это первый элемент
# списка `words1`, сконкатенированный с `sep` и затем с первым элементом `words2`, второй элемент — второй
# элемент `words1`, сконкатенированный с `sep`, а затем со вторым элементом `words2` и т.д.
# Например, `elementwise_concat(['Harry', 'Ron'], ['Potter', 'Weasley'], sep='+')` должен вернуть
# список `['Harry+Potter', 'Ron+Weasley']`. Если параметр `sep` не указан, в качестве разделителя должна
# использоваться пустая строка. То есть `elementwise_concat(['Harry', 'Ron'], ['Potter', 'Weasley'])`
# должен возвращать `['HarryPotter', 'RonWeasley']`

def elementwise_concat(words1, words2, sep=""):
    return [word + sep + another_word for word, another_word in zip(words1, words2)]


# ### Задача 3 (1 балл)
# Написать функцию `Dan_5(grades)`, принимающую на вход словарь `grades`, добавляющую в него запись с ключом `"Dan"`
# и значением `5` и возвращающую этот словарь.
# 
# **Подсказка.** Код должен начинаться со строчки
# 
# ```python
# def Dan_5(grades):
# ```
# 
# и заканчиваться строчкой
# 
# ```python
#     return grades
# ```


def Dan_5(grades):
    grades["Dan"] = 5
    return grades


# ### Задача 4 (1 балл)
# Написать функцию `Dan_plus_1(grades)`, которая принимает на вход словарь `grades`, после чего меняет его следующим
# образом. Если в этом словаре имеется запись с ключом `"Dan"`, то её значение должно быть увеличено на 1.
# Если такой записи нет, она должна быть создана и ей должно быть присвоено значение 1. Функция должна вернуть
# получающийся словарь. Гаранируется, что в словаре `grades` все ключи являются строками, а все значения — целыми
# числами (проверять это не нужно).

def Dan_plus_1(grades):
    dan_grade = grades.get("Dan", 0)
    grades["Dan"] = dan_grade + 1
    return grades


# ### Задача 5 (1 балл)
# Написать функцию `what_about_Dan(grades)`, которая принимает на вход словарь `grades`, после чего возвращает
# строку, в зависимости от значения записи с ключом `"Dan"`. Если такой записи нет, функция должна вернуть
# строку `"Don't know Dan"`. Если такая запись есть и её значением является число, большее 3, функция должна
# вернуть строку `"Dan is fine"`. Если такая запись есть и её значением является число, меньшее или равное 3,
# то функция должна вернуть строку `"Dan needs help"`.


def what_about_Dan(grades):
    dan_grade = grades.get("Dan")
    if dan_grade == None:
        return "Don't know Dan"

    if dan_grade > 3:
        return "Dan is fine"

    if dan_grade <= 3:
        return "Dan needs help"


# ### Задача 6 (1 балл)
# Написать функцию `are_there_more_4(grades)`, проверяющую, есть ли среди *значений* словаря `grades` хоть одно
# число больше 4. Функция должна возвращать `True`, если такое значение есть, и `False` в противном случае.
# Гарантируется, что в словаре есть хотя бы одна запись и значениями словаря являются только числа.
# 
# **Подсказка.** Функция `max` принимает на вход список (или что-то подобное) и выдаёт максимальный элемент.
# Например, `max([1, 3, 2])` вернёт `3`. Её можно использовать в этой задаче и обойтись без циклов. Впрочем, можете
# решить её и с циклами.

def are_there_more_4(grades):
    return max(grades.values()) > 4


# ### Задача 7 (2 балла)
# Написать функцию `flatten_dict(d)`, принимающую на вход словарь `d` и возвращающую список, в который записаны
# последовательно ключи и значения словаря `d` (порядок следования ключей не важен, но после каждого ключа должно
# идти значение, которое ему соответствует). Например, `flatten_dict({'Alice': 1, 'Bob': 2})` может вернуть
# список `['Alice', 1, 'Bob', 2]` или список `['Bob', 2, 'Alice', 1]`.

def flatten_dict(d):
    list = []
    for key in d.keys():
        list.append(key)
        list.append(d[key])

    return list


# ### Задача 8 (2 балла)
# Написать функцию `countlen(words)`, принимающую на вход список строк, а возвращающую словарь, ключами которого
# являются строки из списка `words`, а значениями — их длины (в символах). Например, `countlen(['hello', 'world!'])`
# возвращает словарь `{'hello':5, 'world!':6}`.
# 
# **Подсказка.** Чтобы создать пустой словарь, можно использовать пустые фигурные скобки ``{}``.

def countlen(words):
    return {s: len(s) for s in words}


# ### Задача 9 (3 балла)
#
# *Необязательная задача.*
#
# Напишите функцию `stats(words)`, принимающую на вход список строк и возвращающую самое часто встречающееся слово.
# Если таких слов несколько, следует вернуть то из них, которое в списке встречается первым.
#
# Например, `stats(["qqq", "hello", "hello", "world"])` должна вернуть строчку `"hello"`,
# а `stats(["qqq", "a", "b", "b", "a", "c"])` должна вернуть строку `"a"`. Использовать какие-либо библиотеки нельзя.
# 
# **Подсказка.** Казалось бы, причём здесь словари?

def stats(words):
    dictionary = {}
    for word in words:
        count = dictionary.get(word, 0)
        count += 1
        dictionary[word] = count

    max_count = max(dictionary.values())
    for key in dictionary.keys():
        if dictionary.get(key) == max_count:
            return key


# ### Задача 10 (1 балл)
# 
# Написать функцию `first_str(words)`, принимающую на вход список строк и возвращающую ту из них, которая будет идти
# первой при упорядочивании по алфавиту.
# 
# **Подсказка.** Хотите отсортировать весь список и взять его первый элемент? Это не самое лучшее решение: для
# сортировки всего списка понадобится много времени, если он большой, а вас интересует лишь самый «маленький»
# его элемент. Попробуйте исползовать функцию `min()` — посмотрите, можно ли ей скормить строки вместо чисел.
# Использовать библиотеки нельзя.

def first_str(words):
    return min(words)


# ### Задача 11 (1 балл)
# 
# Написать функцию `get_first_student_grade(students)`, принимающую на вход список `students`, каждый элемент которого
# является кортежем: первый элемент кортежа является именем студента, а второй его оценкой.
# Например: `students = [('Bob', 3), ('Alice', 4)]`. Функция должна вернуть оценку студента, имя которого является
# первым при алфавитной сортировке. (В нашем случае должна вернуть число `4`.) Все студенты имеют разные имена.
# 
# **Подсказка.** См. подсказку к задаче 1. Возможно, функции `min()` удастся скормить кортежи? Попробуйте! Кстати,
# задача решается ровно в одну строчку (не считая `def`). Использовать библиотеки нельзя.

def get_first_student_grade(students):
    return min(zip(students))[0][1]


# ### Задача 12 (2 балла)
# 
# Написать функцию `get_name_of_best_student(students)`, принимающую на вход список `students`, каждый элемент
# которого является кортежем: первый элемент кортежа является именем студента, а второй его оценкой.
# Например: `students = [('Bob', 3), ('Alice', 4)]`. Функция должна вернуть имя студента с наибольшей оценкой.
# Если таких студентов несколько, она должна вернуть имя того из них, кто первый встречается в списке `students`
# (в том порядке, в котором этот список передан). Например, для списка `[('Bob', 4), ('Alice', 4)]` необходимо
# вернуть `'Bob'`, а для списка `[('Alice', 4), ('Bob', 4)]` вернуть `'Alice'`.
# 
# **Подсказка.** У функций `min()` и `max()` есть необязательный параметр `key`, работающий так же, как и у функции
# `sort()`. К чему бы это? Кстати, задачу можно решить без циклов и условных операторов.

def get_name_of_best_student(students):
    return max(students, key=lambda x: x[1])[0]


# ### Задача 13 (2 балла)
# Написать функцию `sort_by_last_name(names)`, которая на вход принимает список строк с именами и фамилиями
# (например, `["Donald Trump", "Hillary Clinton", "Gary Johnson", "Jill Stein", "Darrell Castle", "Evan McMullin"]`),
# сортирующую его по фамилиям и возвращающую в отсортированном виде. (Можно менять исходный список.) Для указанного
# выше списка функция должна вернуть список `['Darrell Castle', 'Hillary Clinton', 'Gary Johnson',
# 'Evan McMullin', 'Jill Stein', 'Donald Trump']`. Порядок записей с одинаковыми фамилиями должен сохраняться.
# Например, для списка `["Alice Smith", "John Doe", "Jack Doe"]` должно быть возвращено
# `["John Doe", "Jack Doe", "Alice Smith"]`.
# 
# **Подсказка.** Вам нужно будет написать функцию, получающую на вход элемент списка `names`
# (то есть одну строку с именем и фамилией) и возвращающую фамилию. Затем эту функцию необходимо передать
# функции `sorted` в качестве параметра `key`.

def sort_by_last_name(names):
    return sorted(names, key=lambda x: x.split(" ")[1])


# ### Задача 14 (2 балла)
# Написать функцию `sort_by_last_first_name(names)`, которая на вход принимает список строк с именами и
# фамилиями, сортирующую его по фамилии, а при совпадении фамилий — по именам, и возвращающую в отсортированном виде.
# (Можно менять исходный список.) Например, для списка `["Alice Smith", "John Doe", "Jack Doe"]` должно быть
# возвращено `["Jack Doe", "John Doe", "Alice Smith"]`.

def sort_by_last_first_name(names):
    return sorted(names, key=sorted_key)


def sorted_key(name):
    first_and_last_name = name.split(" ")
    return (first_and_last_name[1], first_and_last_name[0])


# ### Задача 15 (4 балла)
# 
# *Необязательная задача*
# 
# Написать функцию `sort_gradebook(gradebook)`, принимающую на вход некую ведомость в виде списка, элементами
# которого являются списки такого вида: `[first_name, last_name, grade_1, grade_2, ..., grade_n, final_grade]`,
# где `first_name` — имя студента, `last_name` — его фамилия, `grade_1, ..., grade_n` — оценки студента по
# контрольным от 1 до n (число n — общее число контрольных, оно одинаковое для конкретного gradebook, но заранее
# не известно), `final_grade` — итоговая оценка. Функция должна отсортировать `gradebook` следующим образом
# (и вернуть его отсортированным):
# 
# - По итоговой оценке;
# - При совпадении итоговой оценки — по оценке за первую контрольную;
# - При совпадении всего предыдущего — по оценке за вторую контрольную;
# - При совпадении всего предыдущего — по оценке за третью контрольную (и т.д. пока контрольные не закончатся);
# - При совпадении всех оценок — по фамилии;
# - При совпадении всех оценок и фамилии — по имени.
# 
# Сортировки по оценкам производятся по убыванию, по фамилии по возрастанию, по имени — по убыванию.
# 
# Примеры см. в тестах.
# 
# **Подсказка.** Если при сортировке списка с ключом получаются одинаковые ключи, то порядок следования элементов
# сохраняется. Ключом может быть не только число или строка, но и список.

# YOUR CODE HERE


# ### Задача 16 (2 балла)
# Функция `get_most_ooo_word(words)` принимает на вход строчку, содержащую слова, разделенные пробелами или символами
# перевода строки (одним или несколькими) и возвращает список из тех слов, в которых число букв `o` максимально.
# Например, `get_most_ooo_word('aa ao   oa aaaooo   aooqq aoooq')` должна вернуть `['aaaooo', 'aoooq']`.
# Порядок слов в возвращаемом списке должен соответствовать порядку слов в исходной строке. Написать такую функцию.
#
# **Подсказка.** Посчитать, сколько раз подстрока встречается в строке, можно с помощью метода `count()`.

def get_most_ooo_word(words):
    words = words.replace('\n', '')
    s = words.split(' ')
    m = max(s, key=lambda x: x.count("o")).count("o")
    return [word for word in s if word.count("o") == m and word != '']
