# ### Задача 1 (1 балл).
# Написать функцию `times2(x)`, принимающую на вход число `x` и возвращающую это число, увеличенное в два раза.
# 
# **Подсказка.** Решение должно начинаться со строчки
# 
# ```python
# def times2(x):
# ```
# 
# **Подсказка.** В этом ДЗ вам не придётся вводить данные с клавиатуры. Вместо этого вы будете передавать входные
# данные функции в виде аргументов. Если в условии сказано, что функция должна *вернуть* какое-то
# значение — это означает, что она должна его вернуть (`return`), а не напечатать.

def times2(x):
    return x * 2


# ### Задача 2 (1 балл).
# Написать функцию `is_odd(n)`, проверяющую, является ли данное число `n` нечётным. Она должна возвращать `True`,
# если число нечётное, и `False`, если чётное. Функция не должна ничего выводить на экран!

def is_odd(n):
    return n % 2 != 0


# ### Задача 3 (1 балл).
# Написать функцию `hello(n)`, выводящую на экран строчку `Hello` `n` раз подряд и ничего не возвращающую.
# Например, вызов `hello(3)` должен привести к выводу на экран
# ```
# Hello
# Hello
# Hello
# ```

def hello(n):
    for i in range(n):
        print("Hello")


# ### Задача 4 (2 балла)
# Написать функцию `num_div(n)`, вычисляющую, сколько у данного числа `n` делителей (включая 1 и само это число).
# Функция должна работать с целыми положительными числами.

def num_div(n):
    counter = 0
    for i in range(1, n + 1):
        if n % i == 0:
            counter += 1

    return counter


# ### Задача 5 (1 балл).
# Написать функцию `is_prime(n)`, проверяющую, является ли данное число `n` простым. Она должна вернуть `True`,
# если является, и `False`, если не является.
# 
# **Примечание.** Можете использовать ранее написанную функцию `num_div(n)`. (**Вопрос:** Является ли это самым
# эффективным способом решения данной задачи?)

def is_prime(n):
    return num_div(n) == 2


# ### Задача 6 (2 балла).
# Написать функцию `med3(x,y,z)`, возвращающую медиану из чисел `x`, `y`, `z` (то есть то из этих чисел,
# которое будет стоять посередине, если их упорядочить). Пользоваться какими-либо библиотечными функциями нельзя!
# Сортировкой тоже пользоваться нельзя.

def med3(x, y, z):
    if y <= x <= z or z <= x <= y:
        return x
    elif x <= y <= z or z <= y <= x:
        return y
    else:
        return z


# ### Задача 7 (2 балла)
# Написать функцию `is_increasing(lst, strict)`, проверяющую, является ли список `lst`  возрастающим.
# Если параметр `strict` установлен в `True`, нужно проверять строгое возрастание, иначе нестрогое.
# Иными словами, функция должна возвращать `True`, если каждый элемент списка не меньше (если `strict`
# установлен в `False`) или строго больше (если `strict` установлен в `True`) предыдущего, и `False` в противном случае.
# Если `strict` не указан, функция должна считать, что `strict` установлен в `True`.
# 
# **Это важная задача.** Сделайте её!

def is_increasing(lst, strict=True):
    n = len(lst)
    if n == 1:
        return True

    for i in range(1, n):
        a = lst[i - 1]
        b = lst[i]
        if strict == True:
            if a >= b:
                return False
        else:
            if a > b:
                return False

    return True


# ### Задача 8
# Написать функцию `prod`, которая принимает на вход список чисел и возвращает произведение этих чисел.

def prod(lst):
    result = 1
    for i in lst:
        result *= i

    return result


# ### Задача 9
# Написать функцию `average(list_of_numbers)`, которая принимает на вход список чисел и возвращает его среднее
# арифметическое.

def average(list_of_numbers):
    n = len(list_of_numbers)
    sums = 0
    for i in list_of_numbers:
        sums += i

    return sums / n


# ### Задача 10
# Написать функцию `average_of`, которая принимает на вход несколько чисел и возвращает их среднее арифметическое.
# В отличие от предыдущей задачи, здесь функция должна принимать на вход не один список, а несколько чисел.
# Примеры см. в тесте.
# 
# **Подсказка.** Можно написать функцию, принимающую переменное число аргументов. Как это сделать написано
# [тут](http://nbviewer.math-hse.info/github/ischurov/pythonhse/blob/master/Lecture%204.ipynb#Передача-аргументов).

def average_of(*args):
    n = len(args)
    sums = 0
    for i in args:
        sums += i

    return sums / n


# ### Задача 11 (2 балла)
# Написать функцию `variance(numbers, unbiased)`, принимающую на вход список вещественных чисел `numbers` и
# булевскую переменную `unbiased` и возвращающую
# [выборочную дисперсию](https://ru.wikipedia.org/wiki/Выборочная_дисперсия) для `numbers`.
# Если параметр `unbiased` установлен в `True`, должна возвращаться исправленная (несмещённая) выборочная дисперсия.
# Если параметр `unbiased` не указан, он считается установленным в `True`. Вы можете пользоваться ранее созданными
# функциями, но не можете пользоваться никакими библиотеками.
# 
# **Внимание.** Если тест работает слишком медленно, вероятно, это означает, что ваш код не оптимален и может быть
# не принят проверяющей системой. Подумайте о том, как избежать повторного выполнения одних и тех же действий.

def variance(numbers, unbiased=True):
    n = len(numbers)
    sums = 0
    sums_square = 0
    for number in numbers:
        sums += number
        sums_square += number ** 2

    result = (1 / n) * sums_square - ((1 / n) * sums) ** 2
    if (unbiased):
        return (n / (n - 1)) * result

    return result


# ### Задача 12 (2 балла)
# Итоговая оценка вычисляется по формуле: $\text{накопленная} \times  0.75 + \text{экзамен} \times 0.25$ и
# округляется до целого числа. Если оценка имеет вид «целое + 1/2», то она округляется вверх (то есть до «целое + 1»),
# в остальном округлением происходит к ближайшему целому. Написать функцию `final_grade(acc, exam)`, которая бы
# принимала на вход накопленную и экзаменационную оценки и возвращала итоговую оценку.
# 
# **Подсказка.** Есть функция `round`, но она округляет числа вида «целое + 1/2» к ближайшему чётному.

def final_grade(acc, exam):
    return round(acc * 0.75 + exam * 0.25 + 0.1)


# ### Задача 13 (4 балла)
#
# *Это необязательная задача. Её можно смело пропустить.*
# 
# Рассмотрим некоторое арифметическое выражение, которое может содержать скобки — квадратные или круглые.
# Каждая скобка должна корректно закрываться скобкой такого же типа.
# Например, `5 * [1 + 2 + (3 + 4) + 5]` — корректное выражение, а выражение `4 + (2 + ` некорректное, потому что
# скобка открылась и не закрылась. Также некорректным будет выражение `[1 + (2 + 3] + 4)`, потому что, например,
# первая квадратная скобка должна была закрыться также квадратной, а закрылась круглой.
# 
# Написать функцию `check_brackets(expr)`, принимающую на вход строку, содержащую выражение, и возвращающую `True`,
# если выражение корректное, и `False` в противном случае.
# 
# **Подсказка.** Вам нужно запоминать, в каком порядке какие скобки открывались.
# Когда скобка корректно закрылась, она вас больше не интересует.


def check_brackets(expr):
    stack = []
    for char in expr:
        if char == "[" or char == "(":
            stack.append(char)
        if char == "]" or char == ")":
            if (not stack or
                    (stack[-1] == "(" and char != ")") or
                    (stack[-1] == "[" and char != "]")):
                return False
            stack.pop()
    return not stack
