import pandas as pd

# ### Задача 1 (1 балл)
# В датафрейме `df` находится информация об успеваемости студентов: в столбцах `First Name` и `Last Name` — имя и
# фамилия, а в следующих столбцах — оценки за разные курсы по пятибальной системе (целые числа от 0 до 5).
# Напишите функцию `get_grade(df, lastname, firstname, course)`, возвращающую оценку данного студента по данному курсу.
# Предполагается, что не бывает студентов, у которых совпадали бы одновременно фамилия и имя.
# 
# **Пример:**
# 
# Входная таблица
# 
# ```
#   Last Name First Name  Algebra  Calculus  Music  Law
# 0       Doe       John        4         5      3    5
# 1     Smith      Alice        5         4      2    4
# ```
# записывается в виде
# 
# ```python
# df = pd.DataFrame(
#     [
#         ['Doe', 'John', 4, 5, 3, 5], 
#         ['Smith', 'Alice', 5, 4, 2, 4]
#     ], 
#     columns=['Last Name', 'First Name', 'Algebra', 'Calculus', 'Music', 'Law']
# )
# ```
# Для неё функция `get_grade(df, 'Doe', 'John', 'Algebra')` должна вернуть число `4`.
# 
# **Подсказка.** Не забудьте превратить результат в целое число (`int`)!

def get_grade(df, lastname, firstname, course):
    return int(df[(df['Last Name'] == lastname) & (df['First Name'] == firstname)][course])


# ### Задача 2 (1 балл)
# В датафрейме `df` задана некоторая таблица. Написать функцию `get_rows_after_5(df, n)`, возвращающую датафрейм, в
# котором записано `n` строк, начиная с пятой сверху (включая 5-ю). Например, `get_row_after_5(df, 1)` должна
# вернуть только пятую строку, а `get_row_after_5(df, 2)` — 5-ю и 6-ю.
# 
# **Внимание!** Индексами (именами строк) могут быть не числа, а что угодно.

def get_rows_after_5(df, n):
    return df[4: 4 + n]


# ### Задача 3 (1 балл)
# В датафрейме `df` задана некоторая таблица, её индексами являются целые числа, не обязательно идущие по порядку.
# Написать функцию `between(df, n, m)`, возвращающую все строки этой таблицы, расположенные между строками с
# индексами `n` и `m`, включая строки с индексами `n` и `m`. Гарантируется, что строка с индексом `n` встречается
# раньше строки с индексом `m`.

def between(df, n, m):
    return df.loc[n: m]


# ### Задача 4 (1 балл)
# В датафрейме `grades` находится таблица с оценками разных студентов по разным формам контроля (студент — строка,
# форма контроля — столбец, имена студентов записаны в `index` по строкам и не являются частью таблицы).
# В series `weights` находятся веса, с которыми каждая форма контроля входит в итоговую оценку.
# (Сумма весов равна 1.) Напишите функцию `weight_grades(grades, weights)`, которая возвращает series, в котором
# указано, какой студент какую итоговую оценку получил.
# 
# **Подсказка.** Вам пригодится метод `.dot` для датафрейма, который делает матричное умножение
# (аналог функции `SUMPRODUCT` в табличных процессорах) — умножает каждый элемент строки на соответствующий вес,
# а потом всё складывает.
# 
# Примеры входных и выходных данных см. в тесте.

def weight_grades(grades, weights):
    return grades.dot(weights)


# ### Задача 5 (2 балла)
# Написать функцию `mean_by_gender(grades, genders)`, принимающую на вход два series одинаковой длины: в grades
# записаны оценки некоторых студентов, а в genders — их пол в виде строк male или female. Требуется вернуть словарь,
# ключами которого будут строки `"male"` и `"female"`, а записями — среднее арифметическое оценок студентов
# соответствующего пола.
# 
# Например, если `grades = pd.Series([5, 4, 3, 5, 2])` и
# `genders = pd.Series(["female", "male", "male", "female", "male"])`, функция должна вернуть
# словарь `{'male': 3.0, 'female': 5.0}`.
# 
# **Подсказка.** Вы уже решали похожую задачу в прошлом задании с помощью `numpy`. Подумайте, как это более изящно
# сделать с помощью `pandas`. Можно, конечно, создать два отдельных series, в один поместить оценки всех юношей,
# а в другой — всех девушек, но есть решение и поизящнее: создать датафрейм, столбцами которого являются наши
# series, а затем применить метод `groupby`. Кстати, у series есть метод `to_dict()`.
# 
# Чтобы создать датафрейм с заданными столбцами можно передать `pd.DataFrame` на вход словарь:
# 
#     pd.DataFrame({'column1': [1, 2, 3], 'column2': [4, 5, 6]})


def mean_by_gender(grades, genders):
    df = pd.DataFrame()
    df['Grade'] = grades
    df['Gender'] = genders
    df = df.groupby('Gender').mean()
    return df['Grade'].to_dict()


# ### Задача 6. (2 балла)
# В датафрейме `df` находится информация об успеваемости студентов. Написать функцию `gpa_top(df)`, принимающую
# на вход датафрейм `df` и модифицирующую его следующим образом:
# 
# - Добавить в `df` столбец с именем `'GPA'`, содержащим среднюю оценка студента. Разные студенты могут брать
# разный набор курсов, поэтому среди оценок студентов может встречаться `NaN` (это означает, что студент не
# брал соответствующий курс). Среднее считается среди тех курсов, которые студент брал.
# 
# - Отсортировать датафрейм по убыванию `GPA`.
# 
# - Вернуть только те строчки датафрейма, в которых `GPA` не меньше `4` баллов.
# 
# **Подсказки:** 
# 
# 1. Для сортировки датафрейма нужно использовать метод `sort_values()`.
# 2. Метод `mean()` игнорирует строки и `NaN`'ы.
# 
# В следующих ячейках приведено два примера.

# входной датафрейм

def gpa_top(df):
    df['GPA'] = df.mean(axis=1)
    df.sort_values(by='GPA', ascending=False, inplace=True)
    return df[df['GPA'] >= 4]


# ### Задача 7 (2 балла)
# В таблице `df` записана информация о покупках товаров в некотором магазине. Пример:
#
#             Покупатель     Товар  Количество  Цена
#     0    Иван Петрович  Макароны           4   120
#     1  Лариса Ивановна    Плюшки          10   100
#     2    Иван Петрович    Плюшки           1   100
#     3             Петя   Леденцы           5    20
#     
# Один и тот же товар может продаваться по разным ценам.
# 
# Вам нужно написать функцию `check_table(df)`, возвращающую кортеж из двух словарей: в первом должно быть указано,
# сколько денег оставил в магазине каждый покупатель, а во втором — сколько удалось выручить за продажу каждого
# товара. Например, для приведенной выше таблицы должно быть возвращено
# 
# ```
# ({'Иван Петрович': 580, 'Лариса Ивановна': 1000, 'Петя': 100},
#  {'Леденцы': 100, 'Макароны': 480, 'Плюшки': 1100})
# ```
# 
# **Подсказки:**
# 
# 1. Сначала создайте столбец, в котором будет указано, во сколько обошлась каждая покупка (с учётом количества
# товара и его цены). Одномерные элементы *pandas* (например, столбцы и строки датафреймов — их тип
# называется `pd.DataSeries`) ведут себя как `np.array()`, то есть операции с ними производятся поэлементно.
# 2. Вам поможет метод `groupby()`.
# 3. У элементов типа `pd.DataSeries` есть метод `to_dict()`, превращающий их в словари.

def check_table(df):
    df['Total'] = df['Количество'] * df['Цена']
    return (df.groupby('Покупатель')['Total'].sum().to_dict(), df.groupby('Товар')['Total'].sum().to_dict())


# ### Задача 8 (4 балла)
# В некотором царстве, некотором государстве, раз в четыре года на земском соборе проходят выборы царя.
# Царство имеет федеративную структуру и состоит из земель. Каждая земля имеет право направить на съезд
# определённое число делегатов, чьи голоса и определят президента… ой, то есть царя. У разных земель разное число
# делегатов. По традиции, каждая земля на своей территории проводит выборы самостоятельно, после чего подводится их
# итог и определяется победитель в данной земле. Делегаты, которых отправляют на собор, обязаны проголосовать за того
# кандидата, который набрал в их земле большинство голосов («победитель получает всё»). Царём становится тот кандидат,
# который набрал большинство голосов делегатов. Разные земли имеют разное число делегатов.
# 
# Требуется написать функцию `winner_votes(results)`, возвращающую двухэлементный кортеж: первый элемент — победитель,
# второй — число голосов делегатов, которые он набрал. Функция принимает на вход таблицу (`pd.DataFrame`),
# выглядящую примерно так:
# 
#               state  electors  Arya Stark  Tyrion Lannister  Deineris Targarien
#     0    Winterfell         3         0.6               0.3                 0.1
#     1      Riverrun         5         0.3               0.2                 0.5
#     2  Vaes Dothrak         2         0.2               0.3                 0.5
#     
# В первом столбце указано название земли, во втором — число делегатов от этой земли, в остальных столбцах — доля
# голосов жителей, которые набрал данный кандидат в данной земле.
# 
# Например, для приведенной выше таблицы победителем в `Winterfell` будет `Arya Stark`, в остальных двух
# землях — `Deineris Targarien`. Арья наберёт 3 голоса делегатов, Дейнерис — 7 голосов. Победителем будет Дейнерис.
# Функция должна вернуть `("Deineris Targarien", 7)`.
# 
# Как обычно, запрещено использовать циклы.
#
# В случае, если два кандидата набирают равное число голосов, то побеждает тот, кто идёт первым по алфавиту.
# 
# **Подсказка.** Вам пригодится метод `.idxmax()`. И ещё `.sort_index()`.


def winner_votes(results):
    print("don't complete")
