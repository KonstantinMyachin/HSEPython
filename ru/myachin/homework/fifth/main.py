# ## Часть 1: работа с файлами
# ### Задача 1 (2 балла)
# Написать функцию `sum_ints_in_file(filename)`, принимающую на вход имя файла, содержащего целые числа (каждое число
# на новой строке). Функция должна вернуть сумму этих чисел. Файл может содержать пустые строки, их следует
# игнорировать.
# 
# Не забудьте закрыть файл!

def sum_ints_in_file(filename):
    sums = 0
    with open(filename) as f:
        lines = f.readlines()
        for line in lines:
            if line != '\n':
                sums += int(line)

    return sums


# ### Задача 2 (1 балл)
# Написать функцию `seq(a, b, filename)`, создающую файл `filename` и записывающую в неё целые числа от `a` до `b`
# включительно, каждое число на своей строке. Не забудьте закрыть файл!

def seq(a, b, filename):
    with open(filename, 'w') as f:
        for i in range(a, b + 1):
            print(i, file=f)


# ### Задача 3 (2 балла)
# Написать функцию `censore_haha(filename)`, считывающую файл с именем, лежащем в переменной `filename` и записывающим
# его в новый файл, имя которого получается добавлением к концу имени исходного файла `.censored.txt`. При записи в
# новый файл все вхождения слова `haha` должны быть заменены на `[censored]`.
#
# Например, если функция была вызвана как `censore_haha('test.txt')`, она должна создать файл `test.txt.censored.txt` и
# записать в него отцензурированную версию исходного файла.

def censore_haha(filename):
    with open(filename) as f, open(filename + ".censored.txt", 'w') as fw:
        lines = f.readlines()
        for line in lines:
            print(line.replace("haha", "[censored]"), file=fw, end="")


# ### Задача 4 (3 балла)
# Написать функцию `three_best_applicants(portfolio)`, принимающую на вход имя файла с портфолио в формате,
# аналогичном [этому файлу](http://math-info.hse.ru/f/2017-18/dj-prog/portfolio.txt), и возвращающую список
# фамилий и имён трёх лучших абитуриентов, упорядоченных по числу набранных ими баллов (по убыванию).
# Каждый элемент возвращаемого списка должен был кортежем, в котором на первом месте стоит фамилия студента, а на
# втором — его имя. В файле идет сначала имя, потом фамилия, а потом число баллов, причём между именем и фамилией
# стоит пробел, а между фамилием и числом баллов — символ табуляции (`\t`).

def three_best_applicants(portfolio):
    with open(portfolio) as f:
        dictionary = {}
        lines = f.readlines()
        for line in lines:
            arr = line.split("\t")
            dictionary[arr[0]] = arr[1]

        sorted_dictionary = sorted(dictionary.items(), key=lambda x: int(x[1]), reverse=True)
        result = []
        index = 0
        for i in range(0, 3):
            parts_of_name = sorted_dictionary[i][0].split(" ")
            result.append((parts_of_name[1], parts_of_name[0]))

        return result


# ### Задача 5 (4 балла)
# 
# *Необязательная задача, можно смело пропустить.*
# 
# Функция `save_bill(clientname, cart, filename)` принимает на вход имя клиента, список покупок cart, состоящий из
# трехэлементных кортежей вида `(название товара, количество, цена за единицу)`, и имя файла `filename`.
# Функция должна создать файл, имя которого указано в переменной `filename` с чеком по заданному образцу и ничего
# не возвращать. Все числа должны выводиться в файл с двумя значащами цифрами после десятичной точки.
# Например, `save_bill('Alice', [('Oil', 2, 100.11), ('Bread', 0.345, 90), ('Milk', 1, 50.32)], "somefile.txt")`
# должна создать файл `somefile.txt` со следующим содержимым:
# 
#     Client name: Alice
# 
#     Oil x 2.00: 200.22
#     Bread x 0.34: 31.05
#     Milk x 1.00: 50.32
# 
#     Total: 281.59
# 
# Подсказка. Записать число с двумя знаками после десятичной точки можно так:
# 
#     "{:.2f}".format(12.345)


def save_bill(clientname, cart, filename):
    with open(filename, 'w') as f:
        number_format = "{:.2f}"
        print("Client name: " + clientname, file=f)
        print("\n", file=f, end="")
        total = 0
        for item, count, cost in cart:
            item_total_cost = count * cost
            print(item + " x " + number_format.format(count) + ": " + number_format.format(item_total_cost), file=f)
            total += item_total_cost

        print("\n", file=f, end="")
        print("Total: " + number_format.format(total), file=f)


# ## Часть 2: numpy
# Во всех задачах словом «массив» обозначается объект типа `np.array`. Везде, где не оговорено обратное,
# запрещается пользоваться циклами и list comprehensions!

# ### Задача 6 (1 балл)
# Написать функцию `double_this(arr)`, принимающую на вход массив `arr`, состоящий из чисел, и возвращающую массив,
# полученный удвоением каждого элемента `arr`.
# 
# **Подсказка:** Операции с массивами действуют поэлементно.

def double_this(arr):
    return arr * 2


# ### Задача 7 (1 балл)
# Написать функцию `select_even(arr)`, принимающую на вход массив целых чисел `arr` и возвращающую новый массив,
# который состоит из всех *чётных* элементов `arr`.
# 
# **Подсказка:** напомним, что все арифметические операции, а также операции сравнения, действуют на массивы
# поэлементно.

def select_even(arr):
    return arr[arr % 2 == 0]


# ### Задача 8 (2 балла)
# Написать функцию `wipe_even(arr, target_value, in_place)`, принимающую на вход массив целых чисел `arr`, и
# возвращающую массив, полученный из `arr` путём замены всех чётных элементов на  `target_value`. Если `target_value`
# не указано, то оно должно считаться равным числу 0. Если указан параметр `in_place` и он равен `True`, то функция
# должна менять исходный массив, а если не указан или указан в `False`, то нужно создать копию исходного массива и
# менять эту копию, так, чтобы сам исходный массив остался неизменным.
# 
# **Подсказка.** Чтобы получить копию исходного массива можно использовать метод `.copy()`.


def wipe_even(arr, target_value=0, in_place=False):
    result = arr
    if not in_place:
        result = arr.copy()

    result[result % 2 == 0] = target_value
    return result


# ### Задача 4 (2 балла)
# Написать функцию `weighted_sum(weights, grades, normalize)`, возвращающую взвешенную сумму оценок, записанных в
# массив `grades`, в соответствии с весами, записанными в массив `weights`. Например, для
# `weights = np.array([0.3, 0.3, 0.4])` и `grades = np.array([7, 9, 8])` функция должна вернуть
# число $0.3\times 7+0.3\times 9+0.4\times 8=8.0$.
# 
# Если параметр `normalize` установлен в `True`, а сумма всех весов отличается от 1, то следует умножить все веса на
# одно и то же число таким образом, чтобы их сумма была равна 1, в противном случае следует использовать веса
# «как есть», даже если их сумма отличается от 1. Если функция запущена без указания параметра `normalize`, следует
# считать, что `normalize=False`.
# 
# **Подсказка:** Вам помогут функции `np.dot()` и `np.sum()`. Встроенная функция `sum()` также работает с массивами
# `numpy`, но гораздо медленнее (проверьте с помощью `%timeit`!)

def weighted_sum(weights, grades, normalize=False):
    sum_weights = np.sum(weights)
    if (normalize and sum_weights != 1):
        weights = weights * (1 / sum_weights)

    return np.sum(np.dot(weights, grades))


# ### Задача 5 (2 балла)
# Написать функцию `mean_by_gender(grades, genders)`, принимающую на вход два массива одинаковой длины: в массиве
# `grades` записаны оценки некоторых студентов, а в массиве `genders` — их пол в виде строк `male` или `female`.
# Требуется вернуть словарь, ключами которого будут строки `male` и `female`, а записями — среднее арифметическое
# оценок студентов соответствующего пола.
# 
# Например, если `grades = np.array([5, 4, 3, 5, 2])` и
# `genders = np.array(["female", "male", "male", "female", "male"])`, функция должна вернуть
# словарь `{'male': 3.0, 'female': 5.0}`.
# 
# **Подсказка.** Для быстрого вычисления среднего есть функция `np.mean()` или соответствующий метод у объектов
# типа `numpy.array`.


def mean_by_gender(grades, genders):
    return {'male': np.mean(grades[genders == 'male']), 'female': np.mean(grades[genders == 'female'])}


# ### Задача 6 (3 балла)
# 
# *Необязательная задача, можно пропустить.*
# 
# В некотором царстве, в некотором государстве, налог на доходы физических лиц вычисляется следующим образом.
# Базовая ставка налога составляет 13%. Если в каком-то месяце ваш заработок за год составит больше тысячи тугриков,
# то на оставшуюся часть года (не включая этот месяц) устанавливается ставка в 20%. Например, если вы зарабатываете
# каждый месяц 150 тугриков, то к июлю заработаете $150\times 7 = 1050$ тугриков и начиная с августа подоходный налог
# будет начисляться по ставке 20%. Написать функцию `calculate_tax(income)`, принимающую на вход массив, содержащий
# доход за каждый месяц года, начиная с первого и возвращающую общую сумму налога, который предстоит заплатить за год.
# Год в некотором царстве может длиться более 12 месяцев, если по этому поводу будет принят соответствующий высочайший
# декрет.
# 
# **Подсказка.** Вам поможет функция `np.cumsum()`. Чтобы создать новый массив, длина которого равна длине какого-то
# другого, можно использовать функции `np.zeros_like()` или `np.ones_like()`.

def calculate_tax(income):
    sums = np.cumsum(income)
    less_one_hundred = income[sums <= 1000]
    more_one_hundred = income[sums > 1000]
    result = np.sum(less_one_hundred * 0.13)

    size_more_one_hundred = more_one_hundred.size
    if size_more_one_hundred > 0:
        result += more_one_hundred[0] * 0.13

    if size_more_one_hundred > 1:
        result += np.sum(more_one_hundred[1:] * 0.2)

    return result


# ### Задача 7 (2 балла)
# В задачах машинного обучения часто требуется нормализовать данные перед тем, как их использовать.
# Пусть в переменной `X` находится двумерный `np.array`, по строкам которого записаны разные объекты, а по
# столбцам — признаки. Вам необходимо написать функцию `normalize(X)`, принимающую на вход массив `X` и
# нормализующий все переменные таким образом, чтобы их среднее равнялось 0, а стандартное отклонение 1.
# Иными словами, для каждого столбца необходимо из всех элементов вычесть среднее по этому столбцу и результат
# разделить на стандартное отклонение по этому столбцу. Более формально: если $X=(x_{ij})$ — наша
# матрица, $x_{ij}$ — элемент, который стоит в её $i$-й строке и $j$-м столбце, и $x_{\cdot j}$ — $j$-й столбец,
# то в новой матрице на $i$-й строке в $j$-м столбце будет стоять элемент
# 
# $$\widehat{x}_{ij}=\frac{x_{ij}-\overline{x_{\cdot j}}}{\sigma_{x_{\cdot j}}},$$
# где $\overline{x_{\cdot j}}$ — выборочное среднее (среднее арифметическое) всех
# элементов $j$-го столбца, $\sigma_{x_{\cdot j}}$ — стандартное отклонение всех элементов $j$-го столбца.
# 
# **Подсказка.** Вычислить среднее можно с помощью метода `.mean()`, стандартное отклонение — с помощью `.std()`.
# Обе функции принимают на вход параметр `axis`, с помощью которого можно применять их к строкам или столбцам
# двумерного массива. Использовать циклы, как обычно, запрещено. Задачу можно решить в одну строчку.


def normalize(X):
    return (X - X.mean(axis=0)) / X.std(axis=0)


# ### Задача 8 (3 балла)
# В двумерном массиве `scores` записаны баллы нескольких студентов, строка — студент, столбец — домашнее задание.
# Имеется также массив `max_scores`, который содержит столько же элементов, сколько столбцов в `scores`: в нём
# написано максимальное число баллов, которые можно было получить за соответствующее домашнее задание.
# Теоретически, студент мог нарешать задач на большее количество баллов, но те баллы, которые набраны сверх
# максимального, в зачёт не идут. Оценка за домашнюю работу является вещественным числом от 0 до 10 и определяется
# как *набранные баллы / максимальное число баллов × 10*. Например, если максимальное число баллов за какую-то
# домашнюю работу равно 8, а студент набрал за неё 4 балла, то есть оценка равна *4/8×10=5*. А если бы он
# набрал 12 баллов, то в зачёт бы пошло 8 баллов и оценкой было бы число 10. Оценка по курсу вычисляется как среднее
# арифметическое от всех оценок за домашние работы, округлённое до целого числа с помощью функциюю `np.round`.
# Написать функцию `get_grades(scores, max_scores)`, возвращающую массив итоговых оценок. Запрещено использовать
# циклы и `if`'ы.
#
# **Подсказка.** Вам пригодится функция `np.minimum`.

def get_grades(scores, max_scores):
    arr = np.minimum(scores, max_scores) / max_scores * 10
    return np.round(arr.mean(axis=1))
